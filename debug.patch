--- a/main.go
+++ b/main.go
@@ -9,6 +9,8 @@ import (
 	"errors"
 	"flag"
 	"fmt"
+	"log"
+	"sync"
 	"io"
 	"mime"
 	"net/url"
@@ -33,6 +35,15 @@ var rootDirFlag = flag.String("root", "", "filesystem root (defaults to CWD or $
+// Debug flag & logger (logs to ./log when enabled)
+var debugFlag = flag.Bool("debug", false, "enable debug logging to ./log")
+var dbg *log.Logger
+var dbgMu sync.Mutex
+func dprintf(format string, args ...any) {
+	if dbg == nil { return }
+	dbgMu.Lock()
+	defer dbgMu.Unlock()
+	dbg.Printf(format, args...)
+}
 
 // ---- Types ----
 
@@ -88,6 +99,8 @@ func safeJoin(root, reqPath string) (string, error) {
 	final := filepath.Join(parentResolved, base)
 	finalAbs := mustAbs(final)
 	rootResolved := rootAbs
 	if r2, err := filepath.EvalSymlinks(rootAbs); err == nil { rootResolved = r2 }
-	if !strings.HasPrefix(finalAbs+string(os.PathSeparator), rootResolved+string(os.PathSeparator)) && finalAbs != rootResolved {
+	// ALSO resolve the final path itself to prevent symlink escape via the leaf
+	if fin2, err := filepath.EvalSymlinks(finalAbs); err == nil { finalAbs = fin2 }
+	if !strings.HasPrefix(finalAbs+string(os.PathSeparator), rootResolved+string(os.PathSeparator)) && finalAbs != rootResolved {
 		return "", fmt.Errorf("refusing to access outside root: %s", reqPath)
 	}
 	return finalAbs, nil
@@ -234,11 +247,18 @@ func handleRead(root string) mcp.StructuredToolHandlerFunc[ReadArgs, ReadResult] {
 	return func(ctx context.Context, req mcp.CallToolRequest, args ReadArgs) (ReadResult, error) {
 		var res ReadResult
+		start := time.Now()
+		dprintf("fs_read request args=%+v", args)
 		full, err := safeJoin(root, args.Path)
 		if err != nil { return res, err }
-		fi, err := os.Stat(full)
+		fi, err := os.Lstat(full)
 		if err != nil { return res, err }
+		if (fi.Mode() & os.ModeSymlink) != 0 { return res, fmt.Errorf("refusing to read symlink: %s", args.Path) }
+		// Follow after refusing symlink to get size/mtime of target file
+		fi, err = os.Stat(full)
+		if err != nil { return res, err }
 		b, err := os.ReadFile(full)
 		if err != nil { return res, err }
 		trunc := false
@@ -260,6 +280,7 @@ func handleRead(root string) mcp.StructuredToolHandlerFunc[ReadArgs, ReadResult] {
 			Truncated: trunc,
 			MetaFields: MetaFields{Mode: fmt.Sprintf("%#o", fi.Mode()&os.ModePerm), ModifiedAt: fi.ModTime().UTC().Format(time.RFC3339)},
 		}
+		dprintf("fs_read ok path=%s bytes=%d truncated=%v dur=%s", res.Path, len(b), trunc, time.Since(start))
 		return res, nil
 	}
 }
@@ -267,16 +288,24 @@ func handlePeek(root string) mcp.StructuredToolHandlerFunc[PeekArgs, PeekResult] {
 	return func(ctx context.Context, req mcp.CallToolRequest, args PeekArgs) (PeekResult, error) {
 		if args.MaxBytes <= 0 { args.MaxBytes = 4096 }
 		var res PeekResult
+		start := time.Now()
+		dprintf("fs_peek request args=%+v", args)
 		full, err := safeJoin(root, args.Path)
 		if err != nil { return res, err }
+		if fi, err := os.Lstat(full); err == nil {
+			if (fi.Mode() & os.ModeSymlink) != 0 { return res, fmt.Errorf("refusing to peek symlink: %s", args.Path) }
+		}
 		chunk, sz, eof, err := readWindow(full, args.Offset, args.MaxBytes)
 		if err != nil { return res, err }
 		enc := string(encText)
 		content := string(chunk)
 		if !isText(chunk) { enc = string(encBase64); content = base64.StdEncoding.EncodeToString(chunk) }
-		fi, _ := os.Lstat(full)
+		fi, statErr := os.Lstat(full)
+		var mode os.FileMode = 0
+		var mod string
+		if statErr == nil { mode = fi.Mode() & os.ModePerm; mod = fi.ModTime().UTC().Format(time.RFC3339) }
 		res = PeekResult{
 			Path: args.Path,
 			Offset: args.Offset,
 			Size: sz,
 			EOF: eof,
 			Encoding: enc,
 			Content: content,
-			MetaFields: MetaFields{Mode: fmt.Sprintf("%#o", fi.Mode()&os.ModePerm), ModifiedAt: fi.ModTime().UTC().Format(time.RFC3339)},
+			MetaFields: MetaFields{Mode: fmt.Sprintf("%#o", mode), ModifiedAt: mod},
 		}
+		dprintf("fs_peek ok path=%s off=%d n=%d eof=%v dur=%s", res.Path, res.Offset, len(chunk), eof, time.Since(start))
 		return res, nil
 	}
 }
@@ -284,10 +313,13 @@ func handleWrite(root string) mcp.StructuredToolHandlerFunc[WriteArgs, WriteResult] {
 	return func(ctx context.Context, req mcp.CallToolRequest, args WriteArgs) (WriteResult, error) {
 		var res WriteResult
+		start := time.Now()
+		dprintf("fs_write request args=%+v", args)
 		if args.Encoding == "" { return res, errors.New("encoding is required: text|base64") }
 		full, err := safeJoin(root, args.Path)
 		if err != nil { return res, err }
 		if args.CreateDirs == nil { b := true; args.CreateDirs = &b }
 		if *args.CreateDirs { if err := ensureParent(full); err != nil { return res, err } }
 		mode, err := parseMode(args.Mode)
@@ -364,6 +396,7 @@ func handleWrite(root string) mcp.StructuredToolHandlerFunc[WriteArgs, WriteResult] {
 			SHA256: sha256sum(final),
 			MetaFields: MetaFields{Mode: fmt.Sprintf("%#o", fi.Mode()&os.ModePerm), ModifiedAt: time.Now().UTC().Format(time.RFC3339)},
 		}
+		dprintf("fs_write ok path=%s action=%s bytes=%d created=%v dur=%s", res.Path, action, res.Bytes, created, time.Since(start))
 		return res, nil
 	}
 }
@@ -371,11 +404,15 @@ func handleEdit(root string) mcp.StructuredToolHandlerFunc[EditArgs, EditResult] {
 	return func(ctx context.Context, req mcp.CallToolRequest, args EditArgs) (EditResult, error) {
 		var res EditResult
+		start := time.Now()
+		dprintf("fs_edit request args=%+v", args)
 		if args.Path == "" || args.Pattern == "" { return res, errors.New("path and pattern required") }
 		full, err := safeJoin(root, args.Path)
 		if err != nil { return res, err }
 		fi, err := os.Lstat(full)
 		if err != nil { return res, err }
 		if (fi.Mode() & os.ModeSymlink) != 0 { return res, fmt.Errorf("refusing to edit symlink: %s", args.Path) }
 		if !fi.Mode().IsRegular() { return res, fmt.Errorf("target not a regular file: %s", args.Path) }
@@ -414,6 +451,7 @@ func handleEdit(root string) mcp.StructuredToolHandlerFunc[EditArgs, EditResult] {
 			SHA256: sha256sum(out),
 			MetaFields: MetaFields{Mode: fmt.Sprintf("%#o", mode), ModifiedAt: time.Now().UTC().Format(time.RFC3339)},
 		}
+		dprintf("fs_edit ok path=%s replacements=%d bytes=%d dur=%s", res.Path, count, len(out), time.Since(start))
 		return res, nil
 	}
 }
@@ -421,9 +459,12 @@ func handleList(root string) mcp.StructuredToolHandlerFunc[ListArgs, ListResult] {
 	return func(ctx context.Context, req mcp.CallToolRequest, args ListArgs) (ListResult, error) {
 		var out ListResult
+		start := time.Now()
+		dprintf("fs_list request args=%+v", args)
 		base, err := safeJoin(root, args.Path)
 		if err != nil { return out, err }
 		max := args.MaxEntries
 		if max <= 0 { max = 2000 }
 		count := 0
+		rootPrefix := root + string(os.PathSeparator)
 		add := func(path string, fi os.FileInfo) {
 			if count >= max { return }
 			out.Entries = append(out.Entries, ListEntry{
-				Path: strings.TrimPrefix(path, root+string(os.PathSeparator)),
+				Path: strings.TrimPrefix(path, rootPrefix),
 				Name: fi.Name(),
 				Kind: kindOf(fi),
 				Size: fi.Size(),
@@ -451,6 +492,7 @@ func handleList(root string) mcp.StructuredToolHandlerFunc[ListArgs, ListResult] {
 			add(base, fi)
 		}
 		return out, nil
 	}
 }
@@ -459,16 +501,31 @@ func handleGlob(root string) mcp.StructuredToolHandlerFunc[GlobArgs, GlobResult] {
 	return func(ctx context.Context, req mcp.CallToolRequest, args GlobArgs) (GlobResult, error) {
 		var out GlobResult
+		start := time.Now()
+		dprintf("fs_glob request args=%+v", args)
 		if args.Pattern == "" { return out, errors.New("pattern required") }
 		full, err := safeJoin(root, args.Pattern)
 		if err != nil { return out, err }
 		matches, err := filepath.Glob(full)
 		if err != nil { return out, err }
 		for _, m := range matches {
 			out.Matches = append(out.Matches, strings.TrimPrefix(m, root+string(os.PathSeparator)))
 		}
+		dprintf("fs_glob ok pattern=%s matches=%d dur=%s", args.Pattern, len(out.Matches), time.Since(start))
 		return out, nil
 	}
 }
 
 // ---- main ----
 
 func min(a, b int) int { if a < b { return a } ; return b }
 
 func main() {
 	flag.Parse()
+	// Initialize debug logging if requested
+	if *debugFlag {
+		f, err := os.OpenFile("log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0o644)
+		if err != nil {
+			_, _ = fmt.Fprintf(os.Stderr, "debug: failed to open log file: %v\n", err)
+		} else {
+			dbg = log.New(f, "", log.LstdFlags|log.Lmicroseconds)
+			dprintf("debug logging enabled")
+		}
+	}
 	root, err := getRoot()
 	if err != nil { panic(err) }
+	dprintf("using root=%s", root)
 
 	s := server.NewMCPServer("fs-mcp-go", "0.1.0")

